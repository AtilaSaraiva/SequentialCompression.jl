var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SequentialCompression","category":"page"},{"location":"#SequentialCompression","page":"Home","title":"SequentialCompression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SequentialCompression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SequentialCompression]","category":"page"},{"location":"#SequentialCompression.CompressedArraySeq","page":"Home","title":"SequentialCompression.CompressedArraySeq","text":"CompressedArraySeq{T,Nx}\n\nA mutable structure for storing time-dependent arrays in a compressed format.\n\nFields\n\ndata::Vector{UInt8}: Compressed data in byte form.\nheadpositions::Vector{Int64}: Positions of the beginning of each time slice in data.\ntailpositions::Vector{Int64}: Positions of the end of each time slice in data.\nspacedim::NTuple{Nx,Int32}: Dimensions of the spatial grid.\ntimedim::Int32: Number of time steps.\neltype::Type{T}: Element type of the uncompressed array.\ntol::Float32: Mean absolute error that is tolerated.\nprecision::Float32: Controls the precision, bounding a weak relative error.\nrate::Int64: Fixes the bits used per value.\n\nExample\n\njulia> using SequentialCompression\n\njulia> compArray = CompressedArraySeq(Float64, 4, 4)\nCompressedArraySeq{Float64, 2}(UInt8[], [0], [0], (4, 4), 0, Float64, 0.0f0, 0.0f0, 0)\n\njulia> compArray.timedim\n0\n\n\n\n\n\n","category":"type"},{"location":"#SequentialCompression.CompressedArraySeq-Tuple{AbstractArray{<:AbstractFloat}}","page":"Home","title":"SequentialCompression.CompressedArraySeq","text":"CompressedArraySeq(array::AbstractArray{<:AbstractFloat}; rate::Int=0, tol::Real=0, precision::Real=0)\n\nCreate a new CompressedArraySeq from an uncompressed array.\n\nArguments\n\narray::AbstractArray{<:AbstractFloat}: Initial array to compress and store.\nrate::Int: [Fixes the bits used per value](https://zfp.readthedocs.io/en/release0.5.5/modes.html#fixed-rate-mode).\ntol::Real: [Mean absolute error that is tolerated](https://zfp.readthedocs.io/en/release0.5.5/modes.html#fixed-accuracy-mode).\nprecision::Real: [Controls the precision, bounding a weak relative error](https://zfp.readthedocs.io/en/release0.5.5/modes.html#fixed-precision-mode).\n\nExample\n\njulia> using SequentialCompression\n\njulia> array = [Float64(i + j) for i=1:4, j=1:4];\n\njulia> compArray = CompressedArraySeq(array);\n\njulia> compArray[1] == array\ntrue\n\njulia> compArray.timedim\n1\n\n\n\n\n\n","category":"method"},{"location":"#Base.append!-Union{Tuple{N}, Tuple{T}, Tuple{CompressedArraySeq{T, N}, AbstractArray{T, N}}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.append!","text":"append!(compArray::CompressedArraySeq{T,N}, array::AbstractArray{T,N})\n\nAppend a new time slice to compArray, compressing array in the process.\n\nArguments\n\ncompArray::CompressedArraySeq{T,N}: Existing compressed array.\narray::AbstractArray{T,N}: Uncompressed array to append.\n\nExample\n\njulia> using SequentialCompression\n\njulia> compArray = CompressedArraySeq(Float64, 4, 4);\n\njulia> append!(compArray, ones(4, 4));\n\njulia> compArray[1]\n4Ã—4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> compArray.timedim\n1\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{CompressedArraySeq, Colon}","page":"Home","title":"Base.getindex","text":"getindex(compArray::CompressedArraySeq, timeidx::Colon)\n\nRetrieve and decompress all time slices from compArray.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{CompressedArraySeq, Int64}","page":"Home","title":"Base.getindex","text":"getindex(compArray::CompressedArraySeq, timeidx::Int)\n\nRetrieve and decompress a single time slice from compArray at timeidx.\n\n\n\n\n\n","category":"method"},{"location":"#Base.ndims-Tuple{CompressedArraySeq}","page":"Home","title":"Base.ndims","text":"ndims(compArray::CompressedArraySeq)\n\nReturns the number of dimensions of the uncompressed array, including the time dimension.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{CompressedArraySeq}","page":"Home","title":"Base.size","text":"size(compArray::CompressedArraySeq)\n\nReturns the dimensions of the uncompressed array, with the last dimension being the time dimension.\n\n\n\n\n\n","category":"method"}]
}
