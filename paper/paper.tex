% JuliaCon proceedings template
\documentclass{juliacon}
\graphicspath{{figs/}}
\setcounter{page}{1}

\begin{document}

\input{header}

\maketitle

\begin{abstract}

This package provides a simple interface for storing and retrieving compressed snapshots of an array during a iterative process.
The user can choose between storing them in memory or files in an out-of-core fashion, both with the ZFP algorithm.
In the former, the array is compressed and stored in a vector of bytes.
In the latter, the array is split in their last dimension and then compressed, then written to one file per slice, and one slice per thread.
The results show great performance and the out-of core solution, with great potential for heavy numerical simulations.

\end{abstract}

\section{Introduction}

% TODO: add references to papers that describe this need
It is common in numerical simulations to have to store the state variable, commonly an array, at each or certain iterations of the simulation. This is done for many reasons, such as to be able to restart the simulation from a certain point, to be able to analyze the evolution of the state variable, or to calculate the gradient using the adjoint state method. In this work, we present a package that aims to provide a simple interface to compress arrays that compose the state of a simulation using the ZFP compression algorithm.

This idea of saving the state of a simulation is not new, and it is normally done with sophisticated techniques.
Specifically for the implementation of the adjoint state method, the forward modeling function state has to be stored and then used at each iteration of the adjoint modeling to calculate the gradient. Since the collection of all the states in time is given by the the space dimension of the grid times the number of time iterations, storing it in memory is prohibitive for large models. There are several techniques

% TODO: cite zfpcompression.jl and zfp paper
The ZFP algorithm is a lossy and lossless compression algorithm that is able to compress arrays of floating point numbers targeting numerical simulations. The main argument for its creation was that simulations normally have state barely has any size decrease when using lossless compression given the numbers are all floating point with very little room for deduplication techniques commonly employed by this kind of algorithm. However, lossy compression can use thresholding techniques to decrease the size of the array, but it has to be careful not decrease the signal to noise ratio too much lest not reduce the accuracy of the simulation. The ZFP algorithm allows the user to control how much accuracy, throughput or precision is necessary for their specific problem, and is highly parallelizable. Thus, the package described in this paper uses it in the backend, by leveraging the ZfpCompression.jl package.


\begin{figure*}[t]
    \centerline{\includegraphics{collage.pdf}}
    \caption{This is example of the image in a column.}
    \label{fig:collage}
\end{figure*}
%\begin{figure*}[t]
    %\centerline{\includegraphics{compressedSizeAnalysis.pdf}}
    %\caption{This is example of the image in a column.}
    %\label{fig:compressionSize}
%\end{figure*}

\begin{figure}[t]
    \centerline{\includegraphics{ratio.pdf}}
    \caption{This is example of the image in a column.}
    \label{fig:ratio}
\end{figure}

\begin{figure}[t]
    \centerline{\includegraphics{speeddiff.pdf}}
    \caption{This is example of the image in a column.}
    \label{fig:speeddiff}
\end{figure}
\begin{figure*}[t]
    \centerline{\includegraphics{throughput.pdf}}
    \caption{This is example of the image in a column.}
    \label{fig:throughput}
\end{figure*}



%\input{bib.tex}

\end{document}

% Inspired by the International Journal of Computer Applications template
